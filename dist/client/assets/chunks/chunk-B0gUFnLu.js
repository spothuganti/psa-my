import{r as Ht,c as q,t as F,n as a,u as X,v as Qe,p as g,w as Bt,a as m,f as k,x as ye,y as Q,z as D,A as B,B as Ze,o as d,C as et,D as P,E,F as tt,G as Nt,H as Lt,d as jt,I as nt,J as z,K as M,L as Dt,M as Wt,N as Ut,e as Vt,O as rt,i as Gt,P as Kt,Q as Y,R as ot,S as zt,T as H,U as Mt,l as ae,V as Pe,g as be,W as Yt,m as te,k as Jt,X as qt}from"./chunk-DcLztexp.js";function Xt(){Ht(),q()}function N(e){return typeof e!="object"||e===null?!1:Object.getPrototypeOf(e)===null?!0:e.constructor.name==="Object"}function Qt(){var r,o,i,s;const e=!!((o=(r=window.__REACT_DEVTOOLS_GLOBAL_HOOK__)==null?void 0:r.renderers)!=null&&o.size),t=!!((s=(i=window.__REACT_DEVTOOLS_GLOBAL_HOOK__)==null?void 0:i.rendererInterfaces)!=null&&s.size),n=!!window.__vite_plugin_react_preamble_installed__;return e||t||n}function Ie(e,t){return!F(e)||!F(t)?!1:e.message===t.message}function T(e){window.location.href=e}function Zt(e){return new Promise(t=>setTimeout(t,e))}function en(e,t){let n=!1;return()=>{n||(n=!0,setTimeout(()=>{n=!1,e()},t))}}function it(e){window.addEventListener("visibilitychange",()=>{document.visibilityState==="hidden"&&e()})}function tn(e){window.addEventListener("visibilitychange",()=>{document.visibilityState==="visible"&&e()})}function ne(e,t){a(e===t)}function nn(){let e;return{promise:new Promise(n=>e=n),resolve:e}}Xt();function Ae(e){return"["+e.map(t=>"'"+t+"'").join(", ")+"]"}function re(e,t){const n=Object.getOwnPropertyDescriptor(e,t);return!!n&&!("value"in n)&&!!n.get}function rn(e){return typeof e=="object"&&e!==null&&"then"in e&&X(e.then)}function on(e){return[null,void 0].includes(e)?String(e):["boolean","number","string"].includes(typeof e)?JSON.stringify(e):null}function sn(e){return e.replace(/[/\-\\^$*+?.()|[\]{}]/g,"\\$&")}function V(e,t,n){const r=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(e,t,{...r,enumerable:n})}function oe(e,t,{get:n,...r}){Object.defineProperty(e,t,{...r,get:n})}async function an(e,t){const r=Qe(e,t).filter(i=>i.fileType===".page.server");return await Promise.all(r.map(async i=>{i.exportNames||(a(i.loadExportNames,t),await i.loadExportNames())})),{hasOnBeforeRenderServerSideOnlyHook:r.some(({exportNames:i})=>(a(i),i.includes("onBeforeRender")))}}function un(e,t,n){const{value:r,definedAtData:o}=e;return n&&ln(r,n,t,o),e}function L(e,t,n){const r=e.configValues[t];return r?un(r,t,n):null}function ln(e,t,n,r){a(e!==null);const o=typeof e;if(o===t)return;const i=on(e),s=i!==null?`value ${g.cyan(i)}`:`type ${g.cyan(o)}`,c=`${Bt("Config",n,r)} has an invalid ${s}: it should be a ${g.cyan(t)} instead`;m(!1,c)}const He=["urlPathname","urlParsed"],cn=["Page","pageExports","exports"];function fn(e){[...cn,...He].forEach(n=>{n in e&&(He.includes(n)?(a(n.startsWith("url")),k(!1,`pageContext.${n} is already available in the browser when using Client Routing; adding '${n}' to passToClient has no effect`,{onlyOnce:!0})):k(!1,`pageContext.${n} is a built-in that cannot be overriden; adding '${n}' to passToClient has no effect`,{onlyOnce:!0}),delete e[n])})}const dn="/";function gn(e,t,n){const{pathnameOriginal:r,searchOriginal:o,hashOriginal:i}=ye(e,dn);e.startsWith("/")&&a(e===`${r}${o||""}${i||""}`,{url:e});const s=r.endsWith("/");let u;return u=r+(s?"":"/")+"index",a(u),u=u+t,`${u}${o||""}${i||""}`}const hn=".pageContext.json";function pn(e){return gn(e,hn)}function st(e,{hookName:t,hookFilePath:n}){if(e==null)return;a(!t.endsWith(")"));const r=`The ${g.cyan("pageContext")} object provided by the ${t}() hook defined by ${n}`;m(F(e),`${r} should be an object (but it's ${g.cyan(`typeof pageContext === ${JSON.stringify(typeof e)}`)} instead)`),m(!("_objectCreatedByVike"in e),`${r} shouldn't be the whole ${g.cyan("pageContext")} object, see https://vike.dev/pageContext-manipulation#do-not-return-entire-pagecontext`),k(!("pageId"in e),`${r} sets ${g.cyan("pageContext.pageId")} which means that Vike's routing is overriden. This is an experimental feature: make sure to contact a vike maintainer before using this.`,{onlyOnce:!0}),m(!("is404"in e),`${r} sets ${g.cyan("pageContext.is404")} which is forbidden, use ${g.cyan("throw render()")} instead, see https://vike.dev/render`)}function mn(e,t,n){a(!n.endsWith(" "));const r=[],o=Object.keys(e);for(const i of o)t.includes(i)||r.push(i);m(r.length===0,[n,"returned an object with following unknown keys:",Ae(r)+".","Only following keys are allowed:",Ae(t)+"."].join(" "))}function yn(e,t){if(e==null)return;const n=`The onBeforeRender() hook defined by ${t}`;m(N(e),`${n} should return a plain JavaScript object, ${g.cyan("undefined")}, or ${g.cyan("null")}`),mn(e,["pageContext"],n),e.pageContext&&st(e.pageContext,{hookName:"onBeforeRender",hookFilePath:t})}function Pn(e,t){if(!N(e))return!1;for(const n of Object.keys(e))if(!t.includes(n))return!1;return!0}function at(e,t,n=r=>r){if(a(e.length>0),e.length===1)return n(e[0]);const r=e.slice(0,e.length-1),o=e[e.length-1];return r.map(n).join(", ")+`, ${t} `+n(o)}Q()&&q();const ut="The guard() hook defined by";async function bn(e,t){let n;if(e._pageFilesAll.length>0?(a(e._pageConfigs.length===0),n=wn(e.pageId,e._pageFilesAll)):n=D(e,"guard"),!n)return;const r=n.hookFn;let o=e;const i=t(e);i&&(o=i);const s=await B(()=>r(o),n,e);m(s===void 0,`${ut} ${n.hookFilePath} returns a value, but guard() shouldn't return any value`)}function wn(e,t){const n=t.find(c=>c.pageId===e&&c.fileType===".page.route");if(!n)return null;const{filePath:r,fileExports:o}=n;a(o);const i=o.guard;if(!i)return null;const s=r,u=Ze("guard");return m(X(i),`${ut} ${s} should be a function`),{hookFn:i,hookName:"guard",hookFilePath:s,hookTimeout:u}}function Rn(e,t,n,r,o){const i={abortReason:t,_abortCaller:r,_abortCall:n};if(o&&(a(o._isLegacyRenderErrorPage===!0),d(i,o)),typeof e=="string"){const s=e;return et(s,xn(r)),d(i,{_urlRewrite:s}),ue(i)}else{const s=e;return Cn(e,[401,403,404,410,429,500,503],"render"),d(i,{abortStatusCode:s,is404:s===404}),ue(i)}}function ue(e){const t=new Error("AbortRender");return d(t,{_pageContextAbort:e,[lt]:!0}),t}function Er({pageContext:e={}}={}){var r;k(!1,`${g.cyan("throw RenderErrorPage()")} is deprecated and will be removed in the next major release. Use ${g.cyan("throw render()")} or ${g.cyan("throw redirect()")} instead, see https://vike.dev/render`,{onlyOnce:!1});let t=404,n="Page Not Found";return(e.is404===!1||((r=e.pageProps)==null?void 0:r.is404)===!1)&&(t=500,n="Something went wrong"),d(e,{_isLegacyRenderErrorPage:!0}),Rn(t,n,"RenderErrorPage()","throw RenderErrorPage()",e)}const lt="_isAbortError";function Be(e){return typeof e=="object"&&e!==null&&lt in e}function Sn(e){return e._urlRewrite||e._urlRedirect||e.abortStatusCode?(a(P(e,"_abortCall","string")),!0):!1}function Cn(e,t,n){const r=at(t.map(o=>o.toString()),"or");k(t.includes(e),`Unepexected status code ${e} passed to ${n}(), we recommend ${r} instead. (Or reach out at https://github.com/vikejs/vike/issues/1008 if you believe ${e} should be added.)`,{onlyOnce:!0})}function vn(e){kn(e);const t={_urlRewrite:null};return e.forEach(n=>{Object.assign(t,n)}),t}function kn(e){const t=[];e.forEach(n=>{const r=n._urlRewrite;{const o=t.indexOf(r);if(o!==-1){const i=[...t.slice(o),r].map(s=>`render('${s}')`).join(" => ");m(!1,`Infinite loop of render() calls: ${i}`)}}t.push(r)})}function On(e,t){const n=[e>0&&g.cyan("throw render('/some-url')"),t>0&&g.cyan("throw redirect('/some-url')")].filter(Boolean).join(" and ");m(e+t<=7,`Maximum chain length of 7 ${n} exceeded. Did you define an infinite loop of ${n}?`)}function xn(e){return`URL passed to ${g.code(e)}`}const _n="_pageContextInitIsPassedToClient",ct="_isServerSideError",ft=E("router/getPageContext.ts",{});function Fn(){const e=jt();return m(!("urlOriginal"in e),"Adding 'urlOriginal' to passToClient is forbidden"),ht(e),d(e,{_hasPageContextFromServer:!0}),e}async function $n(e){d(e,{_hasPageContextFromClient:!1});for(const t of["data","onBeforeRender"])if(gt(t,e)){const n=await dt(t,e);a(!("urlOriginal"in n)),Object.assign(e,n)}return e}async function le(e,t){const n={_hasPageContextFromServer:!1};if(!t&&await Tn(e)){const r=await In(e);if("is404ServerSideRouted"in r)return{is404ServerSideRouted:!0};const{pageContextFromServer:o}=r;n._hasPageContextFromServer=!0,a(!(ct in o)),a(!("serverSideError"in o)),d(n,o)}return{pageContextFromServerHooks:n}}async function Ne(e,t){d(e,{_hasPageContextFromClient:!1});for(const r of["guard","data","onBeforeRender"])if(r==="guard")!t&&!e._hasPageContextFromServer&&await bn(e,o=>nt(o,!0));else if(a(r==="data"||r==="onBeforeRender"),gt(r,e)||!e._hasPageContextFromServer){const o=await dt(r,e);a(!("urlOriginal"in o)),Object.assign(e,o)}return e}async function dt(e,t){const n=D(t,e);if(!n)return{};const r=nt(t,!0),o=await B(()=>n.hookFn(r),n,t),i={};if(e==="onBeforeRender"){yn(o,n.hookFilePath);const s=o==null?void 0:o.pageContext;s&&(d(i,{_hasPageContextFromClient:!0}),d(i,s))}else{a(e==="data");const s={data:o};o&&d(i,{_hasPageContextFromClient:!0}),d(i,s)}return i}function En(e){e[_n]&&(ft.pageContextInitIsPassedToClient=!0)}async function Tn(e){return!!ft.pageContextInitIsPassedToClient||await Le("data",e)||await Le("onBeforeRender",e)}async function Le(e,t){var n;if(t._pageConfigs.length>0){const r=tt(t.pageId,t._pageConfigs),o=(n=L(r,`${e}Env`))==null?void 0:n.value;if(o===null)return!1;a(F(o));const{client:i,server:s}=o;return a(i===!0||i===void 0),a(s===!0||s===void 0),a(i||s),!!s&&!i}else{if(e==="data")return!1;a(e==="onBeforeRender");const{hasOnBeforeRenderServerSideOnlyHook:r}=await an(t._pageFilesAll,t.pageId);return r}}function gt(e,t){var n;if(t._pageConfigs.length>0){const r=tt(t.pageId,t._pageConfigs),o=((n=L(r,`${e}Env`))==null?void 0:n.value)??{};return a(F(o)),!!o.client&&!o.server}else return!1}async function In(e){const t=pn(e._urlRewrite??e.urlOriginal),n=await fetch(t);{const i=n.headers.get("content-type"),s="application/json",u=i&&i.includes(s);if(!u&&n.status===404)return T(e.urlOriginal),{is404ServerSideRouted:!0};m(u,`Wrong Content-Type for ${t}: it should be ${s} but it's ${i} instead. Make sure to properly use pageContext.httpResponse.headers, see https://vike.dev/renderPage`)}const r=await n.text(),o=Nt(r);if(a(F(o)),Sn(o))throw ue(o);if("serverSideError"in o||ct in o)throw Lt("pageContext couldn't be fetched because an error occurred on the server-side");return a(P(o,"pageId","string")),ht(o),{pageContextFromServer:o}}function ht(e){fn(e)}function An(e){a(typeof e.urlOriginal=="string"),Pt(e);const t={};return oe(t,"urlPathname",{get:mt,enumerable:!0,configurable:!0}),oe(t,"url",{get:Hn,enumerable:!1,configurable:!0}),oe(t,"urlParsed",{get:Bn,enumerable:!0,configurable:!0}),t}function pt(e){let t,n;e.urlLogical?(t=e.urlLogical,n=!1):e._urlRewrite?(t=e._urlRewrite,n=!1):(t=e.urlOriginal,n=!0),a(t&&typeof t=="string");let r=e._urlHandler;r||(r=i=>i),t=r(t);const o=n?e._baseServer:"/";return ye(t,o)}function mt(){const{pathname:e}=pt(this),t=e;return a(t.startsWith("/")),t}function Hn(){return k(!1,"`pageContext.url` is outdated. Use `pageContext.urlPathname`, `pageContext.urlParsed`, or `pageContext.urlOriginal` instead. (See https://vike.dev/migration/0.4.23 for more information.)",{onlyOnce:!0,showStackTrace:!0}),mt.call(this)}function Bn(){const{hasBaseServer:e,...t}=pt(this),n=Q(),r=i=>{k(n,`pageContext.urlParsed.${i} isn't available on the server-side (HTTP requests don't include the URL hash)`,{onlyOnce:!0,showStackTrace:!0})},o={...t,get hash(){return r("hash"),t.hash},get hashOriginal(){return r("hashOriginal"),t.hashOriginal},get hashString(){return k(!1,"pageContext.urlParsed.hashString has been renamed to pageContext.urlParsed.hashOriginal",{onlyOnce:!0,showStackTrace:!0}),r("hashString"),t.hashOriginal},get searchString(){return k(!1,"pageContext.urlParsed.searchString has been renamed to pageContext.urlParsed.searchOriginal",{onlyOnce:!0,showStackTrace:!0}),t.searchOriginal}};return V(o,"hashString",!1),V(o,"searchString",!1),n||(V(o,"hash",!1),V(o,"hashOriginal",!1)),o}function yt(e){a(typeof e.urlOriginal=="string"),a(typeof e.urlPathname=="string"),a(N(e.urlParsed)),a(e.urlPathname===e.urlParsed.pathname),Pt(e)}function Pt(e){"urlPathname"in e?(a(typeof e.urlPathname=="string"),a(re(e,"urlPathname")),a(re(e,"urlParsed")),a(re(e,"url"))):(a(!("urlParsed"in e)),a(!("url"in e)))}function Nn(e,t){const r=t.filter(({filesystemRoot:i})=>e.startsWith(i)).sort(z(({filesystemRoot:i})=>i.length))[0];let o;if(r){const{filesystemRoot:i,urlRoot:s}=r,u={pageId:e,filesystemRoot:i,urlRoot:s};a(s.startsWith("/")&&e.startsWith("/")&&i.startsWith("/"),u),a(e.startsWith(i),u),i!=="/"?(a(!i.endsWith("/"),u),o=M(e,i.length,0)):o=e,a(o.startsWith("/"),u),o=s+(s.endsWith("/")?"":"/")+M(o,1,0)}else o=e;return a(o.startsWith("/")),o=o.split("/").filter(i=>i!=="pages"&&i!=="src"&&i!=="index").join("/"),a(!o.includes(".page.")),a(!o.endsWith(".")),o.endsWith("/index")&&(o=M(o,0,-6)),o===""&&(o="/"),a(o.startsWith("/")),a(!o.endsWith("/")||o==="/"),o}async function Ln(e,t,n){yt(t);let r=e(t);if(bt(r,`The Route Function ${n}`),r=await r,r===!1)return null;if(r===!0&&(r={}),m(N(r),`The Route Function ${n} should return a boolean or a plain JavaScript object (but it's ${g.cyan(`typeof result === ${JSON.stringify(typeof r)}`)} instead)`),"match"in r){const{match:s}=r;if(m(typeof s=="boolean",`The ${g.cyan("match")} value returned by the Route Function ${n} should be a boolean.`),!s)return null}let o=null;"precedence"in r&&(o=r.precedence,m(typeof o=="number",`The ${g.cyan("precedence")} value returned by the Route Function ${n} should be a number.`)),wt(r,`The ${g.cyan("routeParams")} object returned by the Route Function ${n} should`);const i=r.routeParams||{};return m(!("pageContext"in r),`Providing ${g.cyan("pageContext")} in Route Functions is prohibited, see https://vike.dev/route-function#cannot-provide-pagecontext`),a(N(i)),Object.keys(r).forEach(s=>{m(s==="match"||s==="routeParams"||s==="precedence",`The Route Function ${n} returned an object with an unknown property ${g.cyan(s)} (the known properties are ${g.cyan("match")}, ${g.cyan("routeParams")}, and ${g.cyan("precedence")})`)}),{precedence:o,routeParams:i}}function bt(e,t){k(!rn(e),`${t} returned a promise, but asynchronous routing is deprecated and will be removed in the next major release, see https://vike.dev/route-function#async`,{onlyOnce:!0})}function je(){const e=g.cyan("iKnowThePerformanceRisksOfAsyncRouteFunctions");k(!1,`${e} is deprecated and will be removed in the next major release`,{onlyOnce:!0})}function wt(e,t){a(t.endsWith(" should")),P(e,"routeParams")&&(a(t.endsWith(" should")),m(P(e,"routeParams","string{}"),`${t} be an object holding string values.`))}async function jn(e,t,n,r){await Promise.all(e.filter(u=>u.fileType===".page.route").map(u=>{var c;return(c=u.loadFile)==null?void 0:c.call(u)}));const{onBeforeRouteHook:o,filesystemRoots:i}=Wn(e,t,n);return{pageRoutes:Dn(i,e,t,r),onBeforeRouteHook:o}}function Dn(e,t,n,r){const o=[];if(n.length>0){a(e===null);const i=!0;n.filter(s=>!s.isErrorPage).forEach(s=>{const u=s.pageId;let c=null;{const y="route",h=L(s,y);if(h){const f=h.value;a(h.definedAtData);const O=Dt(h.definedAtData,y);typeof f=="string"?c={pageId:u,comesFromV1PageConfig:i,routeString:f,routeDefinedAtString:O,routeType:"STRING"}:(a(X(f)),L(s,"iKnowThePerformanceRisksOfAsyncRouteFunctions","boolean")&&je(),c={pageId:u,comesFromV1PageConfig:i,routeFunction:f,routeDefinedAtString:O,routeType:"FUNCTION"})}}if(!c){const{routeFilesystem:y}=s;a(y);const{routeString:h,definedBy:f}=y;a(y.routeString.startsWith("/")),c={pageId:u,routeFilesystemDefinedBy:f,comesFromV1PageConfig:i,routeString:h,routeDefinedAtString:null,routeType:"FILESYSTEM"}}a(c),o.push(c)})}if(n.length===0){a(e);const i=!1;r.filter(s=>!Wt(s)).forEach(s=>{const u=t.find(c=>c.pageId===s&&c.fileType===".page.route");if(!u||!("default"in u.fileExports)){const c=Nn(s,e);a(c.startsWith("/")),a(!c.endsWith("/")||c==="/"),o.push({pageId:s,comesFromV1PageConfig:i,routeString:c,routeDefinedAtString:null,routeFilesystemDefinedBy:`${s}.page.*`,routeType:"FILESYSTEM"})}else{const{filePath:c,fileExports:y}=u;if(a(y.default),P(y,"default","string")){const h=y.default;m(h.startsWith("/"),`A Route String should start with a leading slash '/' but ${c} has \`export default '${h}'\`. Make sure to \`export default '/${h}'\` instead.`),o.push({pageId:s,comesFromV1PageConfig:i,routeString:h,routeDefinedAtString:c,routeType:"STRING"});return}if(P(y,"default","function")){const h=y.default;"iKnowThePerformanceRisksOfAsyncRouteFunctions"in y&&je(),o.push({pageId:s,comesFromV1PageConfig:i,routeFunction:h,routeDefinedAtString:c,routeType:"FUNCTION"});return}m(!1,`The default export of ${c} should be a string or a function.`)}})}return o}function Wn(e,t,n){if(t.length>0)return{onBeforeRouteHook:Ut(n,"onBeforeRoute"),filesystemRoots:null};let r=null;const o=[];return e.filter(i=>i.fileType===".page.route"&&i.isDefaultPageFile).forEach(({filePath:i,fileExports:s})=>{if(a(s),"onBeforeRoute"in s){m(P(s,"onBeforeRoute","function"),`\`export { onBeforeRoute }\` of ${i} should be a function.`);const{onBeforeRoute:u}=s,c="onBeforeRoute";r={hookFilePath:i,hookFn:u,hookName:c,hookTimeout:Ze(c)}}"filesystemRoutingRoot"in s&&(m(P(s,"filesystemRoutingRoot","string"),`\`export { filesystemRoutingRoot }\` of ${i} should be a string.`),m(P(s,"filesystemRoutingRoot","string"),`\`export { filesystemRoutingRoot }\` of ${i} is \`'${s.filesystemRoutingRoot}'\` but it should start with a leading slash \`/\`.`),o.push({filesystemRoot:Un(i),urlRoot:s.filesystemRoutingRoot}))}),{onBeforeRouteHook:r,filesystemRoots:o}}function Un(e){a(e.startsWith("/")),a(!e.endsWith("/"));const t=e.split("/"),n=M(t,0,-1).join("/")||"/";return a(n.startsWith("/")),a(!n.endsWith("/")||n==="/"),n}function Rt(){const e="/psa-my/";return a(Vn(e)),e}function Vn(e){return e.startsWith("/")}const ie=E("createPageContext.ts",{});async function St(e){ie.pageFilesData||(ie.pageFilesData=await Vt());const{pageFilesAll:t,allPageIds:n,pageConfigs:r,pageConfigGlobal:o}=ie.pageFilesData,{pageRoutes:i,onBeforeRouteHook:s}=await jn(t,r,o,n),u=Rt();a(rt(u));const c={urlOriginal:e,_objectCreatedByVike:!0,_urlHandler:null,_urlRewrite:null,_baseServer:u,_pageFilesAll:t,_pageConfigs:r,_pageConfigGlobal:o,_allPageIds:n,_pageRoutes:i,_onBeforeRouteHook:s,_isPageContextObject:!0},y=An(c);return d(c,y),c}function Ct(e){const t=e.getAttribute("href");return t===null||!Gt(t)||t===""||Kt(t)||zn(t)||Kn(e)||!Mn(t)||!Gn(e)}function Gn(e){if(Yn()){const n=e.getAttribute("data-vike-link");return n!==null&&n!=="false"}else return!0}function Kn(e){const t=e.getAttribute("target"),n=e.getAttribute("rel");return t==="_blank"||t==="_external"||n==="external"||e.hasAttribute("download")}function zn(e){return!!(e.startsWith("#")||e.includes("#")&&Y(e,{withoutHash:!0})===Y(window.location.href,{withoutHash:!0}))}function Tr(e){return e.startsWith("#")?e===window.location.hash:Y(e)===Y(window.location.href)}function Mn(e){const t=Rt();a(rt(t));const{hasBaseServer:n}=ye(e,t);return n}function Yn(){return!!window._disableAutomaticLinkInterception}function W(e){return e.fileType===".css"?[]:e.exportNames?e.exportNames:(a(e.fileExports,e.filePath),Object.keys(e.fileExports))}function Jn({pageFilesClientSide:e,pageFilesServerSide:t,pageId:n}){return{isHtmlOnly:r(),isClientRouting:i()};function r(){return t.some(u=>u.pageId===n&&u.fileType===".page")?(o(),!1):!(!t.some(u=>u.pageId===n&&u.fileType===".page.server")||e.some(u=>u.pageId===n&&u.fileType===".page.client"&&W(u).includes("render")))}function o(){const s=e.some(u=>W(u).includes("render"));m(s,["No client-side `render()` hook found.","See https://vike.dev/render-modes for more information.",["Loaded client-side page files (none of them `export { render }`):",...e.map((u,c)=>` (${c+1}): ${u.filePath}`)].join(`
`)].join(" "))}function i(){return e.some(u=>W(u).includes("clientRouting"))}}function qn({pageFilesClientSide:e,pageFilesServerSide:t,isHtmlOnly:n,isClientRouting:r}){let o=[];const i=t.filter(u=>!e.includes(u)),s=[];if(s.push(...e.map(u=>({id:u.filePath,onlyAssets:!1,eagerlyImported:!1}))),s.push(...i.map(u=>({id:u.filePath,onlyAssets:!0,eagerlyImported:!1}))),n)o=e.map(u=>u.filePath);else{const u=Xn(r);s.push({id:u,onlyAssets:!1,eagerlyImported:!1}),o=[u]}return{clientEntries:o,clientDependencies:s}}function Xn(e){return e?"@@vike/dist/esm/client/client-routing-runtime/entry.js":"@@vike/dist/esm/client/server-routing-runtime/entry.js"}function Qn(e,t){let n=ot(e,t);const r=Qe(e,t),{isHtmlOnly:o,isClientRouting:i}=Jn({pageFilesClientSide:n,pageFilesServerSide:r,pageId:t});o&&(n=n.filter(c=>c.isEnv("CLIENT_ONLY")&&!W(c).includes("render")),n=er(n));const{clientEntries:s,clientDependencies:u}=qn({pageFilesClientSide:n,pageFilesServerSide:r,isHtmlOnly:o,isClientRouting:i});return{isHtmlOnly:o,isClientRouting:i,clientEntries:s,clientDependencies:u,pageFilesClientSide:n,pageFilesServerSide:r}}async function Zn(e,t,{sharedPageFilesAlreadyLoaded:n}){const r=ot(e,t);await Promise.all(r.map(async o=>{var i;a(o.isEnv("CLIENT_ONLY")||o.isEnv("CLIENT_AND_SERVER")),!(n&&o.isEnv("CLIENT_AND_SERVER"))&&await((i=o.loadExportNames)==null?void 0:i.call(o))}))}function er(e){const t=[];for(const n of e)if(t.push(n),W(n).includes("overrideDefaultPages"))break;return t}function tr(e,t,n){var r,o;if(e){const i=((r=L(e,"clientRouting","boolean"))==null?void 0:r.value)??!1;return{isClientRuntimeLoaded:((o=L(e,"isClientRuntimeLoaded","boolean"))==null?void 0:o.value)??!1,isClientRouting:i}}else{const{isHtmlOnly:i,isClientRouting:s}=Qn(t,n);return{isClientRuntimeLoaded:!i,isClientRouting:s}}}async function ce(e,t){await Zn(t._pageFilesAll,e,{sharedPageFilesAlreadyLoaded:!1});const n=zt(t._pageConfigs,e),{isClientRuntimeLoaded:r,isClientRouting:o}=tr(n,t._pageFilesAll,e);return r&&o}const vt="@",fe=":";function nr(e,t="Invalid"){let n=`${t} Route String ${I(e)}`;m(e!=="",`${n} (empty string): set it to ${I("/")} instead`),m(["/","*"].includes(e[0]),`${n}: it should start with ${I("/")} or ${I("*")}`),m(!e.includes("**"),`${n}: set it to ${I(e.split("**").join("*"))} instead`)}function de(e,t){nr(e);const n=we(e),r=n.map(f=>f.param?"[^/]+":f.glob?".*":sn(f.static)).map(f=>`(${f})`).join(""),o=new RegExp(`^${r}/?$`),i=t.match(o);if(!i)return null;const s={},[u,...c]=i;let y=0;const h=n.filter(f=>f.glob).length>1;return n.forEach((f,O)=>{let x=c[O];if(f.param&&(s[f.param]=x),f.glob){const j=`*${h?++y:""}`;s[j]=x}}),{routeParams:s}}function we(e){const t=[],n=o=>{const i=t[t.length-1];i!=null&&i.static?i.static+=o:t.push({static:o})},r=e.split("/");return r.forEach((o,i)=>{i!==0&&n("/"),or(o)?(k(!o.startsWith(fe),`Outdated Route String ${I(e)}, use ${I(e.split(fe).join(vt))} instead`,{onlyOnce:!0}),t.push({param:o.slice(1)})):o==="*"&&i===r.length-1&&e!=="*"&&e!=="/*"?t.push({glob:!0}):o.split("*").forEach((s,u)=>{u!==0&&t.push({glob:!0}),s!==""&&n(s)})}),t}function rr(e){const t=[];return we(e).forEach(r=>{r.param&&t.push(r.param)}),t}function G(e){const t=we(e),n=u=>(u==null?void 0:u.split("/").filter(Boolean).length)||0;let r=0;for(const u of t){if(!u.static)break;r+=n(u.static)}const o=t.map(u=>n(u.static)).reduce((u,c)=>u+c,0),i=t.filter(u=>u.param).length,s=t.filter(u=>u.glob).length;return{numberOfStaticPartsBeginning:r,numberOfStaticParts:o,numberOfParams:i,numberOfGlobs:s}}function or(e){return e.startsWith(vt)||e.startsWith(fe)}function De(e){const n=de(e,e);return a(n),Object.keys(n.routeParams).length===0}function I(e){return Q()?`'${e}'`:(e===""&&(e="''"),g.cyan(e))}function ir(e){e.sort(sr).sort(H(t=>t.routeType==="FUNCTION"&&!!t.precedence&&t.precedence<0)).sort(H(t=>t.routeType==="STRING"&&De(t.routeString)===!1)).sort(H(t=>t.routeType==="FUNCTION"&&!t.precedence)).sort(H(t=>t.routeType==="STRING"&&De(t.routeString)===!0)).sort(H(t=>t.routeType==="FILESYSTEM")).sort(H(t=>t.routeType==="FUNCTION"&&!!t.precedence&&t.precedence>0))}function sr(e,t){{const n=e.precedence??0,r=t.precedence??0;if(n!==r)return n>r?-1:1}if(!t.routeString||!e.routeString)return 0;{const r=z(o=>G(o).numberOfStaticPartsBeginning)(e.routeString,t.routeString);if(r!==0)return r}{const r=z(o=>G(o).numberOfStaticParts)(e.routeString,t.routeString);if(r!==0)return r}{const r=Mt(o=>G(o).numberOfGlobs)(e.routeString,t.routeString);if(r!==0)return r}{const r=z(o=>G(o).numberOfParams)(e.routeString,t.routeString);if(r!==0)return r}return 0}async function ar(e){const t={};if(!e._onBeforeRouteHook)return null;const n=await ur(e._onBeforeRouteHook,e);return n&&(d(t,n),P(t,"pageId","string")||P(t,"pageId","null"))?(P(t,"routeParams")?a(P(t,"routeParams","object")):d(t,{routeParams:{}}),d(t,{_routingProvidedByOnBeforeRouteHook:!0,_debugRouteMatches:"CUSTOM_ROUTING"}),t):(d(t,{_routingProvidedByOnBeforeRouteHook:!1}),t)}async function ur(e,t){let n=e.hookFn(t);bt(n,`The onBeforeRoute() hook ${e.hookFilePath}`),n=await B(()=>n,e,t);const r=`The onBeforeRoute() hook defined by ${e.hookFilePath}`;if(m(n==null||Pn(n,["pageContext"])&&P(n,"pageContext"),`${r} should return ${g.cyan("null")}, ${g.cyan("undefined")}, or a plain JavaScript object ${g.cyan("{ pageContext: { /* ... */ } }")}`),n==null)return null;if(m(P(n,"pageContext","object"),`${r} returned ${g.cyan("{ pageContext }")} but pageContext should be a plain JavaScript object.`),P(n.pageContext,"pageId")&&!P(n.pageContext,"pageId","null")){const s=`${r} returned ${g.cyan("{ pageContext: { pageId } }")} but ${g.cyan("pageId")} should be`;m(P(n.pageContext,"pageId","string"),`${s} a string or null`),m(t._allPageIds.includes(n.pageContext.pageId),`${s} ${at(t._allPageIds.map(u=>g.cyan(u)),"or")}`)}P(n.pageContext,"routeParams")&&wt(n.pageContext,`${r} returned ${g.cyan("{ pageContext: { routeParams } }")} but routeParams should`);const o=s=>`${r} returned ${g.cyan(`{ pageContext: { ${s} } }`)} which is deprecated. Return ${g.cyan("{ pageContext: { urlLogical } }")} instead.`;P(n.pageContext,"url")&&(k(!1,o("url"),{onlyOnce:!0}),n.pageContext.urlLogical=n.pageContext.url,delete n.pageContext.url),P(n.pageContext,"urlOriginal")&&(k(!1,o("urlOriginal"),{onlyOnce:!0}),n.pageContext.urlLogical=n.pageContext.urlOriginal,delete n.pageContext.urlOriginal),P(n.pageContext,"urlLogical")&&et(n.pageContext.urlLogical,`${r} returned ${g.cyan("{ pageContext: { urlLogical } }")} but ${g.cyan("urlLogical")}`),st(n.pageContext,{hookFilePath:e.hookFilePath,hookName:"onBeforeRoute"});const i={};return d(i,n.pageContext),i}var K;function We(...e){var t;K||(K=(t=globalThis.__brillout_debug_createDebugger)==null?void 0:t.call(globalThis,"vike:routing")),K&&K(...e)}Q()&&q();async function kt(e){We("Pages routes:",e._pageRoutes),yt(e);const t={},n=await ar(e);if(n){if(n._routingProvidedByOnBeforeRouteHook)return a(n.pageId),n;d(t,n)}d(e,n);const r=e._allPageIds;m(r.length>0,"No page found. You must create at least one page."),a(e._pageFilesAll.length>0||e._pageConfigs.length>0);const{urlPathname:o}=e;a(o.startsWith("/"));const i=[];await Promise.all(e._pageRoutes.map(async u=>{const{pageId:c,routeType:y}=u;if(u.routeType==="FILESYSTEM"){const{routeString:h}=u,f=de(h,o);if(f){const{routeParams:O}=f;i.push({pageId:c,routeParams:O,routeString:h,routeType:y})}return}if(u.routeType==="STRING"){const{routeString:h}=u,f=de(h,o);if(f){const{routeParams:O}=f;a(y==="STRING"),i.push({pageId:c,routeString:h,routeParams:O,routeType:y})}return}if(u.routeType==="FUNCTION"){const{routeFunction:h,routeDefinedAtString:f}=u,O=await Ln(h,e,f);if(O){const{routeParams:x,precedence:j}=O;i.push({pageId:c,precedence:j,routeParams:x,routeType:y})}return}a(!1)})),ir(i);const s=i[0]??null;if(We(`Route matches for URL ${g.cyan(o)} (in precedence order):`,i),d(t,{_debugRouteMatches:i}),d(t,{_routeMatch:s}),!s)return d(t,{pageId:null,routeParams:{}}),t;{const{routeParams:u}=s;a(N(u)),d(t,{pageId:s.pageId,routeParams:s.routeParams})}return t}const Ot=E("getPageContextCurrent.ts",{pageContextCurrent:null});function xt(){const{pageContextCurrent:e}=Ot;return e}function Ue(e){Ot.pageContextCurrent=e}const J=5e3,Ve={staticAssets:"hover",pageContext:J},ge={staticAssets:"hover",pageContext:!1},lr=ge;function Re(e,t){let n=lr;if("prefetchLinks"in e.exports&&m(!1,"`export { prefetchLinks }` is deprecated, use `export { prefetchStaticAssets }` instead."),"prefetchStaticAssets"in e.exports){const r=e.exports.prefetchStaticAssets;n.staticAssets=r}if("prefetch"in e.exports){const{prefetch:r}=e.exports;r===!0&&(n=Ve),r===!1&&(n=ge),Object.assign(n,r),n.pageContext===!0&&(n.pageContext=J)}if(n.staticAssets,t){{let r=t.getAttribute("data-prefetch");r!==null&&(r===""&&(r="true"),r==="true"&&(n=Ve),r==="false"&&(n=ge))}{let r=t.getAttribute("data-prefetch-static-assets");r!==null&&(r==="false"&&(n.staticAssets=!1),n.staticAssets=r)}{let r=t.getAttribute("data-prefetch-page-context");if(r!==null){r===""&&(r="true"),r==="true"&&(n.pageContext=J),r==="false"&&(n.pageContext=!1);const o=parseInt(r,10);Number.isNaN(o)||(n.pageContext=o)}}}return n}q();const _=E("prefetch.ts",{linkPrefetchHandlerAdded:new WeakSet,addLinkPrefetchHandlers_debounce:null,mutationObserver:new MutationObserver(Se),linkTags:document.getElementsByTagName("A"),prefetchedPageContexts:{}});function cr(e){if(!Re(e,null).pageContext)return null;const n=Ce(e.urlPathname),r=_.prefetchedPageContexts[n];return!r||r.result.is404ServerSideRouted||Ft(r)?null:r.result.pageContextFromServerHooks}async function fr(e){try{await ae(e.pageId,e._pageFilesAll,e._pageConfigs)}catch(t){if(Pe(t))me(t,!0);else throw t}}async function dr(e,t){const n=await le(e,!1);_t(e,n,t)}function Ge(e,t){ve()&&_t(e,t,null)}function _t(e,t,n){n===null&&(n=gr());const r=Ce(e.urlPathname);a(ve()),_.prefetchedPageContexts[r]={resultFetchedAt:Date.now(),resultMaxAge:n,result:t}}function gr(){const e=xt();if(!e)return 1/0;const t=Re(e,null);return typeof t.pageContext=="number"?t.pageContext:J}function Se(){_.addLinkPrefetchHandlers_debounce&&clearTimeout(_.addLinkPrefetchHandlers_debounce),_.addLinkPrefetchHandlers_debounce=setTimeout(()=>{"requestIdleCallback"in window?requestIdleCallback(Ke,{timeout:300}):setTimeout(Ke,150)},250)}function Ir(){Se()}function hr(){_.mutationObserver.observe(document.body,{childList:!0,subtree:!0})}function pr(){_.mutationObserver.disconnect()}function Ke(){for(let e of _.linkTags){if(_.linkPrefetchHandlerAdded.has(e)||(_.linkPrefetchHandlerAdded.add(e),Ct(e)))continue;e.addEventListener("mouseover",()=>{se(e,"hover")},{passive:!0}),e.addEventListener("touchstart",()=>{se(e,"hover")},{passive:!0}),new IntersectionObserver(n=>{n.forEach(r=>{r.isIntersecting&&se(e,"viewport")})}).observe(e)}}async function se(e,t){let n;const r=xt();if(r)n=Re(r,e);else if(ve())n={staticAssets:"hover",pageContext:1/0};else return;if(Ct(e))return;const o=e.getAttribute("href"),i=await mr(o);i!=null&&i.pageId&&(a(P(i,"pageId","string")),await ce(i.pageId,i)&&await Promise.all([(async()=>{n.staticAssets===t&&await fr(i)})(),(async()=>{if(t!=="viewport"&&n.pageContext){const s=Ce(o),u=_.prefetchedPageContexts[s];if(!u||Ft(u)){const c=n.pageContext;await dr(i,c)}}})()]))}function Ft(e){return Date.now()-e.resultFetchedAt>e.resultMaxAge}async function mr(e){const t=await St(e);let n;try{n=await kt(t)}catch{return null}return d(t,n),t}function Ce(e){return e.startsWith("#")&&(e="/"),a(e.startsWith("/"),{urlPathname:e}),e.split("#")[0]}function ve(){return"_isBrilloutDocpress"in window}Rr();const he=E("history.ts",{previous:Fe()});function $t(){const e=Et();if(U(e))return;const t=yr(e);_e(t)}function yr(e){const t=xe(),n=Oe(),r="browser";let o;return e?o={timestamp:e.timestamp??t,scrollPosition:e.scrollPosition??n,triggeredBy:e.triggeredBy??r,_isVikeEnhanced:!0}:o={timestamp:t,scrollPosition:n,triggeredBy:r,_isVikeEnhanced:!0},a(U(o)),o}function ke(){const e=Et();return a(U(e),{state:e}),e}function Et(){return window.history.state}function Oe(){return{x:window.scrollX,y:window.scrollY}}function xe(){return new Date().getTime()}function ze(){const e=Oe(),t=ke();_e({...t,scrollPosition:e})}function Pr(e,t){if(t)_e(ke(),e);else{const n={timestamp:xe(),scrollPosition:null,triggeredBy:"vike",_isVikeEnhanced:!0};window.history.pushState(n,"",e)}}function _e(e,t){const n=t??null;window.history.replaceState(e,"",n)}function Ar(){["pushState","replaceState"].forEach(e=>{const t=window.history[e].bind(window.history);window.history[e]=(n={},...r)=>{m(n==null||F(n),`history.${e}(state) argument state must be an object`);const o=U(n)?n:{_isVikeEnhanced:!0,scrollPosition:Oe(),timestamp:xe(),triggeredBy:"user",...n};a(U(o));const i=t(o,...r);return he.previous=Fe(),i}})}function U(e){const t=F(e)&&"_isVikeEnhanced"in e;return t&&br(e),t}function br(e){a(F(e)),a(P(e,"_isVikeEnhanced","true")),a(P(e,"timestamp","number")),a(P(e,"scrollPosition")),e.scrollPosition!==null&&(a(P(e,"scrollPosition","object")),a(P(e.scrollPosition,"x","number")&&P(e.scrollPosition,"y","number")))}function Fe(){return{url:be(),state:ke()}}function wr(){const{previous:e}=he,t=window.history.state===null;t&&$t();const n=Fe();return he.previous=n,{isNewState:t,previous:e,current:n}}function Rr(){$t()}function Tt(e){if(e&&"x"in e){It(e);return}if(e!=null&&e.preserveScroll)return;const t=Cr();Sr(t)}function Sr(e){if(!e)Me();else{const t=decodeURIComponent(e),n=document.getElementById(t)||document.getElementsByName(t)[0];n?(n.scrollIntoView(),n.focus()):e==="top"&&Me()}}function Me(){It({x:0,y:0})}function It(e){const t=()=>window.scrollTo(e.x,e.y),n=()=>window.scrollX===e.x&&window.scrollY===e.y;n()||(t(),!n()&&requestAnimationFrame(()=>{t(),!n()&&setTimeout(async()=>{if(t(),n())return;const r=new Date().getTime();for(;;)if(await Zt(10),t(),n()||new Date().getTime()-r>100)return},0)}))}function Cr(){let{hash:e}=window.location;return e===""?null:(a(e.startsWith("#")),e=e.slice(1),e)}function Hr(){window.addEventListener("scroll",en(ze,Math.ceil(1e3/3)),{passive:!0}),it(ze)}const At=E("scrollRestoration.ts",{});function Br(){Ye(),it(Ye),tn(()=>At.initialRenderIsDone&&$e())}function vr(){At.initialRenderIsDone=!0}function $e(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual")}function Ye(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="auto")}const S=E("renderPageClientSide.ts",(()=>{const{promise:e,resolve:t}=nn();return{previousPageContext:null,renderCounter:0,firstRenderStartPromise:e,firstRenderStartPromiseResolve:t}})()),{firstRenderStartPromise:Nr}=S;async function pe(e){const{urlOriginal:t=be(),overwriteLastHistoryEntry:n=!1,isBackwardNavigation:r,pageContextsFromRewrite:o=[],redirectCount:i=0,doNotRenderIfSamePage:s,isClientSideNavigation:u=!0,pageContextInitClient:c}=e;let{scrollTarget:y}=e;const{previousPageContext:h}=S;pr();const{isRenderOutdated:f,setHydrationCanBeAborted:O,isFirstRender:x}=Or();if(On(o.length,i),S.clientRoutingIsDisabled){T(t);return}if(S.firstRenderStartPromiseResolve(),f())return;await j();return;async function j(){const b=async l=>{await Te({err:l})},p=await Ee(!1);if(!f()){if(S.isFirstRenderDone&&(a(h),te(h,"onPageTransitionStart"),!S.isTransitioning)){S.isTransitioning=!0;const l=D(h,"onPageTransitionStart");if(l){const v=l,{hookFn:w}=v;try{await B(()=>w(p),v,p)}catch(R){await b(R);return}if(f())return}}if(x){const l=Fn();a(!("urlOriginal"in l)),d(p,l),Ge(p,{pageContextFromServerHooks:l})}else{let l;try{l=await kt(p)}catch(R){await b(R);return}if(f())return;if(!l.pageId){T(t);return}a(P(l,"pageId","string"));const v=await ce(l.pageId,p);if(f())return;if(!v){T(t);return}const w=l.pageId&&(h==null?void 0:h.pageId)&&l.pageId===h.pageId;if(s&&w)return;a(!("urlOriginal"in l)),d(p,l)}try{d(p,await ae(p.pageId,p._pageFilesAll,p._pageConfigs))}catch(l){if(Je(l,p,x))return;await b(l);return}if(!f()&&(Ue(p),p.exports.hydrationCanBeAborted?O():k(!Qt(),"You seem to be using React; we recommend setting hydrationCanBeAborted to true, see https://vike.dev/hydrationCanBeAborted",{onlyOnce:!0}),!f()))if(x){a(P(p,"_hasPageContextFromServer","true"));let l;try{l=await $n(p)}catch(v){await b(v);return}if(f())return;ne(p,l),await Z(p)}else{let l;const v=cr(p);if(v)l=v;else try{const R=await le(p,!1);if(R.is404ServerSideRouted)return;l=R.pageContextFromServerHooks,Ge(p,R)}catch(R){await b(R);return}if(f())return;a(!("urlOriginal"in l)),d(p,l);let w;try{w=await Ne(p,!1)}catch(R){await b(R);return}if(f())return;ne(p,w),await Z(p)}}}async function Ee(b){const p=await St(t);d(p,{isBackwardNavigation:r,isClientSideNavigation:u,isHydration:x&&!b,previousPageContext:h,...c}),Object.defineProperty(p,"_previousPageContext",{get(){return k(!1,"pageContext._previousPageContext has been renamed pageContext.previousPageContext",{showStackTrace:!0,onlyOnce:!0}),h},enumerable:!1});{const l=vn(o);a(!("urlOriginal"in l)),d(p,l)}return p}async function Te(b){const p=C=>{Ie(C,b.err)||console.error(C)};if("err"in b){const{err:C}=b;a(C),Be(C)||console.error(C)}const l=await Ee(!0);if(f())return;if(b.is404&&d(l,{is404:!0}),b.pageContextError&&d(l,b.pageContextError),"err"in b){const{err:C}=b;if(a(!("errorWhileRendering"in l)),l.errorWhileRendering=C,Be(C)){const $=C._pageContextAbort;if($._urlRewrite){await pe({...e,scrollTarget:void 0,pageContextsFromRewrite:[...o,$]});return}if($._urlRedirect){const ee=$._urlRedirect.url;if(ee.startsWith("/"))await pe({...e,scrollTarget:void 0,urlOriginal:ee,overwriteLastHistoryEntry:!1,isBackwardNavigation:!1,redirectCount:i+1});else{T(ee);return}return}a($.abortStatusCode),a(!("urlOriginal"in $)),d(l,$),$.abortStatusCode===404&&d(l,{is404:!0})}else d(l,{is404:!1})}const v=qt(l._pageFilesAll,l._pageConfigs);if(!v)throw new Error("No error page defined.");d(l,{pageId:v});const w=await ce(l.pageId,l);if(f())return;if(!w){T(t);return}try{d(l,await ae(l.pageId,l._pageFilesAll,l._pageConfigs))}catch(C){if(Je(C,l,x))return;p(C);return}if(f())return;Ue(l);let R;try{const C=await le(l,!0);if(C.is404ServerSideRouted)return;R=C.pageContextFromServerHooks}catch(C){p(C);return}if(f())return;a(!("urlOriginal"in R)),d(l,R);let A;try{A=await Ne(l,!0)}catch(C){p(C);return}f()||(ne(l,A),d(l,{routeParams:{}}),await Z(l,b))}async function Z(b,p){const l=async w=>{p?Ie(w,p.err)||console.error(w):await Te({err:w})};if(S.onRenderClientPromise&&(await S.onRenderClientPromise,a(S.onRenderClientPromise===void 0),f()))return;kr(t,n),S.previousPageContext=b,a(S.onRenderClientPromise===void 0),S.onRenderClientPromise=(async()=>{let w;try{await Jt(b,!0)}catch(R){w=R}return S.onRenderClientPromise=void 0,S.isFirstRenderDone=!0,w})();const v=await S.onRenderClientPromise;if(a(S.onRenderClientPromise===void 0),!(v&&(await l(v),!p))){if(x&&!v){te(b,"onHydrationEnd");const w=D(b,"onHydrationEnd");if(w){const{hookFn:R}=w;try{await B(()=>R(b),w,b)}catch(A){if(await l(A),!p)return}if(f(!0))return}}if(!f(!0)){if(S.isTransitioning){S.isTransitioning=void 0,a(h),te(h,"onPageTransitionEnd");const w=D(h,"onPageTransitionEnd");if(w){const{hookFn:R}=w;try{await B(()=>R(b),w,b)}catch(A){if(await l(A),!p)return}if(f(!0))return}}if(!y&&h){const w=qe(h),R=qe(b);R!==!1&&w!==!1&&xr(R,w)&&(y={preserveScroll:!0})}Tt(y),$e(),vr(),b._hasPageContextFromServer&&En(b),hr(),Se()}}}}function kr(e,t){be()!==e&&($e(),Pr(e,t))}function Je(e,t,n){if(!Pe(e))return!1;if(n)throw me(e,!1),e;return me(e,!0),T(t.urlOriginal),!0}function me(e,t){a(Pe(e)),S.clientRoutingIsDisabled=!0,t&&console.log(e),Yt(!1,["Failed to fetch static asset.","This usually happens when a new frontend is deployed.","Falling back to Server Routing.","(The next page navigation will use Server Routing instead of Client Routing.)"].filter(Boolean).join(" "),{onlyOnce:!0})}function Or(){const e=++S.renderCounter;a(e>=1);let t=!1;return{isRenderOutdated:o=>e===1&&!t&&!o?!1:e!==S.renderCounter,setHydrationCanBeAborted:()=>{t=!0},isFirstRender:e===1}}function Lr(){return S.renderCounter}function qe(e){const t=e.from.configsStandard.keepScrollPosition;if(!t)return!1;let n=t.value;const r=t.definedAt;a(r);const o=rr(r);return X(n)&&(n=n(e,{configDefinedAt:t.definedAt})),n===!0?[r,...o.map(i=>{const s=e.routeParams[i];return a(s),s})]:n}function xr(e,t){return e===t?!0:!Array.isArray(e)||!Array.isArray(t)?!1:e.length===t.length&&e.every((n,r)=>e[r]===t[r])}const _r=E("initOnPopState.ts",{listeners:[]});function jr(){window.addEventListener("popstate",async()=>{const{isNewState:e,previous:t,current:n}=wr(),r=n.state.scrollPosition||void 0,o=n.state.triggeredBy==="user"||t.state.triggeredBy==="user",i=Xe(n.url)===Xe(t.url)&&n.url!==t.url,s=i&&e,u=!n.state.timestamp||!t.state.timestamp?null:n.state.timestamp<t.state.timestamp;if(i){s||Tt(r);return}let c=o,y;_r.listeners.forEach(h=>{y||(y=h({previous:t}))}),!y&&(y===!1&&(c=!1),await pe({scrollTarget:r,isBackwardNavigation:u,doNotRenderIfSamePage:c}))})}function Xe(e){return e.split("#")[0]}export{Er as R,de as a,Ct as b,Ir as c,Rr as d,Br as e,Nr as f,Lr as g,Hr as h,Tr as i,jr as j,Ar as m,pe as r,Sr as s};
